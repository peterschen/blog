@page
@model PassDemo.Ui.Pages.Weather.IndexModel
@{
    ViewData["Title"] = "Weather Dashboard";
}

<h1>Weather Dashboard</h1>

<div class="row mb-4">
    <div class="col-md-3">
        <label for="startDateInput" class="form-label">Start Date (UTC)</label>
        <input type="datetime-local" id="startDateInput" class="form-control" disabled
               value="@Model.StartDate.ToString("yyyy-MM-ddTHH:mm")" />
    </div>
    <div class="col-md-3">
        <label for="endDateInput" class="form-label">End Date (UTC)</label>
        <input type="datetime-local" id="endDateInput" class="form-control" disabled
               value="@Model.EndDate.ToString("yyyy-MM-ddTHH:mm")" />
    </div>
    <div class="col-md-3">
        <label for="pollingInterval" class="form-label">Polling Interval</label>
        <select id="pollingInterval" class="form-select">
            <option value="1000">1 Second</option>
            <option value="10000">10 Seconds</option>
            <option value="30000" selected>30 Seconds</option>
            <option value="60000">1 Minute</option>
            <option value="300000">5 Minutes</option>
        </select>
    </div>
    <div class="col-md-3 d-flex align-items-end">
        <button id="refreshRangeButton" class="btn btn-primary w-100">Refresh Manual Range</button>
        <button id="goLiveButton" class="btn btn-success w-100" style="display: none;">Go Live</button>
    </div>
</div>

<div class="card">
    <div class="card-header">Weather Data</div>
    <div class="card-body" style="height: 400px;">
        <canvas id="weatherChart"></canvas>
    </div>
</div>

<div class="alert alert-info mt-3" role="alert">
    <strong>Note:</strong> Data is for Hamburg. All times are UTC.
</div>

@section Scripts {
    <script>
        // Use 'let' to declare variables that will be reassigned.
        let weatherChart;
        let pollingTimer;
        let isLiveMode = true;

        // --- DOM Element References ---
        // It's good practice to get all element references once.
        const ctx = document.getElementById('weatherChart').getContext('2d');
        const startDateInput = document.getElementById('startDateInput');
        const endDateInput = document.getElementById('endDateInput');
        const pollingIntervalSelect = document.getElementById('pollingInterval');
        const refreshRangeButton = document.getElementById('refreshRangeButton');
        const goLiveButton = document.getElementById('goLiveButton');

        const apiEndpoint = '/api/weatherdata';

        // --- Core Functions ---
         /**
         * Updates the UI elements (buttons, inputs) based on the current mode.
         */
        function updateUiForMode() {
            if (isLiveMode) {
                goLiveButton.style.display = 'none';
                refreshRangeButton.style.display = 'inline-block';
                startDateInput.disabled = true;
                endDateInput.disabled = true;
            } else {
                goLiveButton.style.display = 'inline-block';
                refreshRangeButton.style.display = 'none';
                startDateInput.disabled = false;
                endDateInput.disabled = false;
            }
        }

        /**
         * Sets the values of the datetime-local inputs.
         * Correctly handles timezone offset for local display.
         */
        function setDateInputs(startDate, endDate) {
            const toLocalISOString = date => new Date(date.getTime() - (date.getTimezoneOffset() * 60000)).toISOString().slice(0, -8);
            startDateInput.value = toLocalISOString(startDate);
            endDateInput.value = toLocalISOString(endDate);
        }

        /**
         * Initializes a new Chart.js instance and assigns it to the weatherChart variable.
         * This function is the main entry point.
         */
        function setupDashboard() {
            weatherChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [], // Time labels will go here
                    datasets: [
                        {
                            label: 'Temperature (°C)',
                            data: [],
                            borderColor: 'rgb(255, 99, 132)',
                            yAxisID: 'yTemp'
                        },
                        {
                            label: 'Humidity (%)',
                            data: [],
                            borderColor: 'rgb(54, 162, 235)',
                            yAxisID: 'yHumidity'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'minute', tooltipFormat: 'yyyy-MM-dd HH:mm:ss' },
                            title: { display: true, text: 'Time (UTC)' }
                        },
                        yTemp: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: 'Temperature (°C)' },
                            min: -5,
                            max: 15
                        },
                        yHumidity: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: { display: true, text: 'Humidity (%)' },
                            grid: { drawOnChartArea: false },
                            min: 60,
                            max: 100
                        }
                    },
                    plugins: { tooltip: { mode: 'index', intersect: false } }
                }
            });

            // After the chart is created, perform the first data fetch and start polling.
            fetchAndPoll();
        }

        /**
         * Fetches weather data from the API and updates the chart.
         */
        async function fetchWeatherData() {
            // Defensive check: Do nothing if the chart object doesn't exist for any reason.
            if (!weatherChart) {
                console.error("fetchWeatherData called before chart was initialized.");
                return;
            }

            if (isLiveMode) {
                const now = new Date();
                const lastHour = new Date(now.getTime() - 1 * 60 * 60 * 1000);
                startTs = lastHour.getTime();
                endTs = now.getTime();
                // Update the disabled inputs to reflect the live window
                setDateInputs(lastHour, now);
            } else {
                // Manual mode: read the static values from the inputs
                startTs = new Date(startDateInput.value).getTime();
                endTs = new Date(endDateInput.value).getTime();
            }

            weatherChart.options.scales.x.min = startTs;
            weatherChart.options.scales.x.max = endTs;

            try {
                const [tempResponse, humidityResponse] = await Promise.all([
                    fetch(`${apiEndpoint}?startTimestamp=${startTs}&endTimestamp=${endTs}&dataType=Temperature`),
                    fetch(`${apiEndpoint}?startTimestamp=${startTs}&endTimestamp=${endTs}&dataType=Humidity`)
                ]);

                const tempData = await tempResponse.json();
                const humidityData = await humidityResponse.json();

                // Convert Unix timestamp (long) from API back to JavaScript Date objects for the chart.
                const tempPoints = tempData.map(item => ({ x: new Date(item.timestamp), y: item.value }));
                const humidityPoints = humidityData.map(item => ({ x: new Date(item.timestamp), y: item.value }));

                // Update the chart's data properties.
                weatherChart.data.datasets[0].data = tempPoints;
                weatherChart.data.datasets[1].data = humidityPoints;

                // Tell Chart.js to re-render.
                weatherChart.update('none'); 
            } catch (error) {
                console.error("Error fetching or processing weather data:", error);
            }
        }

        /**
         * Clears any existing polling timer and starts a new one with the selected interval.
         */
        function startPolling() {
            clearInterval(pollingTimer); // Always clear the old timer first.
            const interval = parseInt(pollingIntervalSelect.value);

            if (!isNaN(interval) && interval > 0) {
                pollingTimer = setInterval(fetchWeatherData, interval);
                console.log(`Polling restarted with interval: ${interval / 1000} seconds`);
            }
        }

        /**
         * A single handler to fetch data and restart polling when filters change.
         */
        async function fetchAndPoll() {
            await fetchWeatherData(); // Wait for the initial fetch to complete.
            startPolling();       // Then, restart the polling timer.
        }

        /**
         * Switches the dashboard to manual mode.
         */
        function switchToManualMode() {
            if (isLiveMode) {
                isLiveMode = false;
                console.log("Switched to manual mode. Polling paused.");
                clearInterval(pollingTimer);
                updateUiForMode();
            }
        }

        // --- Event Listeners ---
        
        // This is the main entry point.
        document.addEventListener('DOMContentLoaded', setupDashboard);

        // When user changes a date, switch to manual mode and stop polling.
        startDateInput.addEventListener('change', switchToManualMode);
        endDateInput.addEventListener('change', switchToManualMode);

        // The refresh button only works in manual mode to fetch data for the selected range.
        refreshRangeButton.addEventListener('click', () => {
            isLiveMode = false;
            updateUiForMode();
            fetchWeatherData();
        });

        // The "Go Live" button switches back to live mode and restarts polling.
        goLiveButton.addEventListener('click', () => {
            isLiveMode = true;
            updateUiForMode();
            fetchAndPoll(); // Fetch latest data and resume polling.
        });

        // Changing the interval should always restart the polling timer.
        pollingIntervalSelect.addEventListener('change', startPolling);

    </script>
}